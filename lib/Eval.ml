open Yojson.Basic.Util
open RN

(* This module is used to parse the json output of batfish in orient format of 'index' *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)
module DStringMap = Map.Make(
  struct type t = string * string
    let compare (s1, s2) (s3, s4) =
      match String.compare s1 s3 with
      | 0 -> String.compare s2 s4
      | c -> c
  end) 

module StringMap = Map.Make(
  struct type t = string
    let compare s1 s2 = String.compare s1 s2
  end)

type header =
  | Loc
  | SrcIp
  | SrcPorts
  | DstIp
  | DstPorts
  | Protocol
  
type man = {
  nodes: int StringMap.t;
  edges: (string*string)DStringMap.t;
  protocols: int StringMap.t;
  interface: (pred*pred)DStringMap.t;
}

let insert_edge = DStringMap.add

let insert_node (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (2 * (StringMap.cardinal map)) map

let insert_protocol (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (StringMap.cardinal map) map

let edgesMap_to_string (edges:(string*string)DStringMap.t) : string =
  let str = ref "" in
  DStringMap.iter (fun (node1,interface1) (node2,interface2) ->
    str := !str ^ "Edge: " ^ node1 ^ " " ^ interface1 ^ " -> " ^ node2 ^ " " ^ interface2 ^ "\n"
  ) edges;
  !str

let nodesMap_to_string (nodes: int StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun node id ->
    str := !str ^ "Node: " ^ node ^ " ID: " ^ string_of_int id ^ "\n"
  ) nodes;
  !str

let protocol_map_to_string (protocols: int StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun protocol id ->
    str := !str ^ "Protocol: " ^ protocol ^ " ID: " ^ string_of_int id ^ "\n"
  ) protocols;
  !str


let parse_edges_to_map (edges:Yojson.Basic.t) : (string*string)DStringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let s1 = entry |> member "Interface" |> member "hostname" |> to_string in
        let s2 = entry |> member "Interface" |> member "interface" |> to_string in
        let s3 = entry |> member "Remote_Interface" |> member "hostname" |> to_string in
        let s4 = entry |> member "Remote_Interface" |> member "interface" |> to_string in
        aux (insert_edge (s1, s2) (s3, s4) acc) (`Assoc xs)
    |  _ -> failwith "Unexpected JSON format for edges, please check the json generated by the batfish is in orient format of 'index'"
  in
  aux DStringMap.empty edges

let parse_nodes_to_map (nodes:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((s, _)::xs) ->
        aux (insert_node s acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for nodes, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux StringMap.empty nodes

let parse_protocols_to_map (protocols:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        if String.equal (entry |> member "Structure_Type" |> to_string) "IP_Access_List" then
          let protocols = [entry] |> filter_member "Structure_Definition" |> filter_member "lines" |> flatten |> filter_member "matchCondition" |> filter_member "headerSpace" |> filter_member "ipProtocols" |> flatten |> filter_string  in
          aux (List.fold_left (fun acc proto -> insert_protocol proto acc) acc protocols) (`Assoc xs)
        else
          aux acc (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux (StringMap.singleton "TCP" 0) protocols

let get_filter_name (filter:Yojson.Basic.t) : string =
  match filter with
  | `Null -> ""
  | `String s -> s
  | _ -> failwith "Unexpected JSON format for filter, please check the json generated by the batfish is in orient format of 'record'"  

let parse_interfaces_to_map (interfaces:Yojson.Basic.t) : (string*string)DStringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, table)::xs) ->
        let income_filter = table |> member "Incoming_Filter_Name" |> get_filter_name in
        let outgoing_filter = table |> member "Outgoing_Filter_Name" |> get_filter_name in
        let node = table |> member "Interface" |> member "hostname" |> to_string in
        let interface = table |> member "Interface" |> member "interface" |> to_string in
        aux (insert_edge (node, interface) (income_filter, outgoing_filter) acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for interfaces, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux DStringMap.empty interfaces

(* The length of an integer in bits *)

let length_of_int (num:int) : int =
  let rec aux n acc =
    if n = 0 then acc
    else aux (n lsr 1) (acc + 1)
  in
  aux (num + 1) 0

let get_field_length (man:man) : int =
  let nodes_length = length_of_int (StringMap.cardinal man.nodes) in
  let protocols_length = length_of_int (StringMap.cardinal man.protocols) in
  nodes_length + 32 + 16 + 32 + 16 + protocols_length + 1
  (* nodes dstip dstports srcip protocol *)

(* Convert a binary number to a predicate *)  
let rec binary_to_pred (start:int) (length:int) (shifter:int) (num:int) : pred =
  match length with
  | 0 -> True (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           Test (start,false)
         else
           Test (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           And (Test (start, false), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)
         else
           And (Test (start, true), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)

let rec binary_to_pkr (start:int) (length:int) (shifter:int) (num:int) : pkr =
  match length with
  | 0 -> Id (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           RightAsgn (start,false)
         else
           RightAsgn (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           Comp (RightAsgn (start, false), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)
         else
           Comp (RightAsgn (start, true), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)

          
let header_placement (header:header) (man: man) : int =
  match header with
  | Loc -> 0
  | DstIp -> length_of_int (StringMap.cardinal man.nodes)
  | DstPorts -> 32 + (length_of_int (StringMap.cardinal man.nodes))
  | SrcIp -> 48 + (length_of_int (StringMap.cardinal man.nodes))
  | SrcPorts -> 80 + (length_of_int (StringMap.cardinal man.nodes))
  | Protocol -> 96 + (length_of_int (StringMap.cardinal man.nodes))

let partial_header_placement (header:header) (nodesmap: int StringMap.t) : int =
  match header with
  | Loc -> 0
  | DstIp -> length_of_int (StringMap.cardinal nodesmap)
  | DstPorts -> 32 + (length_of_int (StringMap.cardinal nodesmap))
  | SrcIp -> 48 + (length_of_int (StringMap.cardinal nodesmap))
  | SrcPorts -> 80 + (length_of_int (StringMap.cardinal nodesmap))
  | Protocol -> 96 + (length_of_int (StringMap.cardinal nodesmap))


let parse_protocols_to_pred (protocols:string list) (man:man) : pred =
  let rec aux acc = function
    | [] -> acc
    | x::xs ->
        let id = StringMap.find x man.protocols in
        let protocol_length = length_of_int (StringMap.cardinal man.protocols) in
        aux (Or (acc, binary_to_pred (header_placement Protocol man) protocol_length (protocol_length-1) id)) xs
  in
  if List.length protocols = 0 then
    True
  else
    aux False protocols

let partial_parse_protocols_to_pred (protocols:string list) (protocol_map:int StringMap.t) : pred =
  let rec aux acc = function
    | [] -> acc
    | x::xs ->
        let id = StringMap.find x protocol_map in
        let protocol_length = length_of_int (StringMap.cardinal protocol_map) in
        aux (Or (acc, binary_to_pred (partial_header_placement Protocol protocol_map) protocol_length (protocol_length-1) id)) xs
  in
  if List.length protocols = 0 then
    True
  else
    aux False protocols


let parse_location_to_pred (loc:string) (start:int) (local:bool) (man: man) : pred =
  try
    let id = (StringMap.find loc man.nodes) + (if local then 1 else 0) in
      let length = length_of_int (StringMap.cardinal man.nodes) in
      binary_to_pred start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_location_to_pkr (loc:string) (start:int) (local:bool) (man: man) : pkr =
  try
    let id = (StringMap.find loc man.nodes) + (if local then 1 else 0) in
      let length = length_of_int (StringMap.cardinal man.nodes) in
      binary_to_pkr start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")
 
let parse_ip_entry_string (ip:string) : int * int =
  Scanf.sscanf ip "%d.%d.%d.%d/%d" (fun a b c d e-> (a lsl 24 + b lsl 16 + c lsl 8 + d,e))

let parse_ip_string (ip:string) : int =
  Scanf.sscanf ip "%d.%d.%d.%d" (fun a b c d-> a lsl 24 + b lsl 16 + c lsl 8 + d)  

let find_next_loc (loc:string) (interface:string) (man: man) : string =
  try
    let (node, _) = DStringMap.find (loc, interface) man.edges in
    node
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)

let find_next_loc_filter (loc:string) (interface:string) (man: man) : pred =
  try
    fst (DStringMap.find (DStringMap.find (loc, interface) man.edges) man.interface)
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)
  

let match_ip_string (ip1:int) (ip2:int) (mask:int) : bool =
  let mask = 0xFFFFFFFF lsl (32 - mask) in
  ip1 land mask = ip2 land mask

let compare_data = (fun entry1 entry2 ->
           let ip1 = entry1 |> member "Network" |> to_string in
           let ip2 = entry2 |> member "Network" |> to_string in
           let (_, mask1) = parse_ip_entry_string ip1 in
           let (_, mask2) = parse_ip_entry_string ip2 in
           compare mask2 mask1
         )

let parse_ip_wildcard (ip:string) : int * int =
  if String.contains ip '/' then
    parse_ip_entry_string ip
  else
    (parse_ip_string ip, 32)

let rec get_ge_pred (start:int) (shifter:int) (number:int) : pred =
  if shifter = 0 then
    if number land 1 = 0 then
      True
    else
      Test (start, true)
  else
    if (number lsr shifter) land 1 = 0 then
      Or (Test (start, true), get_ge_pred (start + 1) (shifter - 1) number)
    else
      And (Test (start, true), get_ge_pred (start + 1) (shifter - 1) number)

let rec get_le_pred (start:int) (shifter:int) (number:int) : pred =
  if shifter = 0 then
    if number land 1 = 1 then
      True
    else
      Test (start, false)
  else
    if (number lsr shifter) land 1 = 1 then
      Or (Test (start, false), get_le_pred (start + 1) (shifter - 1) number)
    else
      And (Test (start, false), get_le_pred (start + 1) (shifter - 1) number)

let rec parse_ports (ports:Yojson.Basic.t) (nodesmap:int StringMap.t) (dst:bool): pred =
  match ports with
  | `List ((`String s)::xs) ->
      let (lo,hi) = Scanf.sscanf s "%d-%d" (fun a b -> (a, b)) in
      let ge_lo_pred = get_ge_pred (partial_header_placement (if dst then DstPorts else SrcPorts) nodesmap) 15 lo in
      let le_hi_pred = get_le_pred (partial_header_placement (if dst then DstPorts else SrcPorts) nodesmap) 15 hi in
      let ports_pred = And (ge_lo_pred, le_hi_pred) in
      Or (ports_pred, parse_ports (`List xs) nodesmap dst)
  | `List [] -> False
  | _ -> failwith "Unexpected JSON format for ports, please check the json generated by the batfish is in orient format of 'record'"
  
let string_of_ip (ip:int) : string =
  let a = (ip lsr 24) land 0xFF in
  let b = (ip lsr 16) land 0xFF in
  let c = (ip lsr 8) land 0xFF in
  let d = ip land 0xFF in
  Printf.sprintf "%d.%d.%d.%d" a b c d  

let rec parse_protocol_filter (node:string) (named_structure:string) (protocols:Yojson.Basic.t) (nodesmap:int StringMap.t) (protocol_map:int StringMap.t): pred =
  if (String.equal named_structure "") then
    True
  else
  match protocols with
  | `Assoc ((_, entry)::xs) ->
      let structure_type = entry |> member "Structure_Type" |> to_string in
      let structure_name = entry |> member "Structure_Name" |> to_string in
      let structure_node = entry |> member "Node" |> to_string in
      if (String.equal structure_type "IP_Access_List") && (String.equal structure_name named_structure) && (String.equal structure_node node) then
        let local_entries = entry |> member "Structure_Definition" |> member "lines" |> to_list in
        let rec aux (acc:pred) = function
          | [] -> False
          | x::xs ->
              let action = x |> member "action" |> to_string in
              let accept = if String.equal action "PERMIT" then true else
                if String.equal action "DENY" then false else
                  failwith ("Unexpected action: " ^ action) in
              let src_and_dst_pred = 
                try (let (dstip,dst_mask) = x |> member "matchCondition" |> member "headerSpace" |> member "dstIps" |> member "ipWildcard" |> to_string |> parse_ip_wildcard in
                     let dst_pred = binary_to_pred (partial_header_placement DstIp nodesmap) dst_mask 31 dstip in
                     let (srcip,src_mask) = x |> member "matchCondition" |> member "headerSpace" |> member "srcIps" |> member "ipWildcard" |> to_string |> parse_ip_wildcard in
                     let src_pred = binary_to_pred (partial_header_placement SrcIp nodesmap) src_mask 31 srcip in
                     let dstports_pred =
                      try
                       parse_ports (x |> member "matchCondition" |> member "headerSpace" |> member "dstPorts") nodesmap true
                      with _ -> True in
                     let srcports_pred =
                      try
                       parse_ports (x |> member "matchCondition" |> member "headerSpace" |> member "srcPorts") nodesmap false
                      with _ -> True in                
                     And (And (src_pred, srcports_pred), And (dst_pred, dstports_pred)))
               with _ -> 
                let (src_or_dst_ip, src_or_dst_mask) = 
                  try x |> member "matchCondition" |> member "headerSpace" |> member "srcOrDstIps" |> member "prefix" |> to_string |> parse_ip_wildcard
                  with _ -> (0,0) in
                let src_pred =
                   binary_to_pred (partial_header_placement SrcIp nodesmap) src_or_dst_mask 31 src_or_dst_ip in
                let dst_pred =
                    binary_to_pred (partial_header_placement DstIp nodesmap) src_or_dst_mask 31 src_or_dst_ip in
                Or (src_pred, dst_pred) in
              (* Parse the source and destination IPs *)
              let protocol_list = [x] |> filter_member "matchCondition" |> filter_member "headerSpace" |> filter_member "ipProtocols" |> flatten |> filter_string  in
              let protocol_pred = partial_parse_protocols_to_pred protocol_list protocol_map in
              (* Construct the new filter *)  
              let new_filter =  (And (src_and_dst_pred, protocol_pred)) in
              if accept then
                (* If the action is accept, we combine the new filter with the existing one *)
                (Or (And (Neg acc,new_filter), aux (Or (acc, new_filter)) xs))
              else
                (* If the action is deny, we negate the new filter and combine it with the existing one *)
                aux (Or (acc, new_filter)) xs
        in
        aux False local_entries
      else
        parse_protocol_filter node named_structure (`Assoc xs) nodesmap protocol_map
  | `Assoc []  
  | `List [] ->  False
  | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'"

let init_man (nodes:Yojson.Basic.t) (edges:Yojson.Basic.t) (protocols:Yojson.Basic.t) (interfaces:Yojson.Basic.t): man =
  let nodesmap = parse_nodes_to_map nodes in
  let protocol_map = parse_protocols_to_map protocols in
  {
    nodes = nodesmap;
    edges = parse_edges_to_map edges;
    protocols = protocol_map;
    interface = DStringMap.mapi 
      (fun (node,_) (in_filter, out_filter) -> (parse_protocol_filter node in_filter protocols nodesmap protocol_map, parse_protocol_filter node out_filter protocols nodesmap protocol_map)
    ) (parse_interfaces_to_map interfaces);
  }

let post_pred_pkr (pred:pred) (pkr:pkr) : pkr =
  (AndP (Binary (True,pred), pkr))

let parse_local_routing_table (loc:string) (tables: Yojson.Basic.t list)  (man:man) : pkr = 
   let rec aux (re_routing_list: (int*pred) list) (action_list:(int*int*pred*pkr) list) (filter:pred) = function
    | [] -> (re_routing_list, action_list)
    | table::xs ->
        let ip = table |> member "Network" |> to_string in
        let (ip, mask) = parse_ip_entry_string ip in
        let ip_filter = binary_to_pred (header_placement DstIp man) mask 31 ip in
        let interface = table |> member "Next_Hop_Interface" |> to_string in
          if String.equal interface "dynamic" then
            let route_ip = table |> member "Next_Hop_IP" |> to_string in
            let route_ip = parse_ip_string route_ip in
            aux (re_routing_list @ [(route_ip, And (Neg filter,ip_filter))]) action_list (Or (filter, ip_filter)) xs
          else let next_loc_pkr = 
                  if String.equal interface "Loopback0"
                    then post_pred_pkr (snd (DStringMap.find (loc, interface) man.interface)) (parse_location_to_pkr loc (header_placement Loc man) true man) 
                    (* Setting the discard the testing interface *)
                  else if String.equal interface "null_interface" 
                    then Binary (False,False)
                    (* Neglect the interface sending to nowhere/outside network *)
                  else try post_pred_pkr (snd (DStringMap.find (loc, interface) man.interface))
                    (post_pred_pkr (find_next_loc_filter loc interface man)
                    (parse_location_to_pkr (find_next_loc loc interface man) (header_placement Loc man) false man))
                    with _ -> Binary (False,False) in
            aux re_routing_list (action_list @ [(ip,mask, And (Neg filter,ip_filter), next_loc_pkr)]) (Or (filter, ip_filter)) xs
    in
  let (re_routing_list, action_list) = aux [] [] False (List.sort compare_data tables) in
    let rec action_lookup (action_list:(int*int*pred*pkr) list) (ip:int) : pkr =
      match action_list with
      | [] -> Binary (False,False)
      | (ip2,mask,_,action)::xs ->
          if match_ip_string ip ip2 mask then
            action
          else action_lookup xs ip
    in
    List.fold_right (fun (ip,pred) acc -> OrP (AndP (Binary (pred,True), action_lookup action_list ip), acc)) re_routing_list
      (List.fold_right (fun (_,_,pred,action) acc -> OrP (AndP (Binary (pred,True), action), acc)) action_list (Binary (False,False)))

let rec parse_global_routing_table (table:Yojson.Basic.t) (man:man) : pkr = 
  match table with
  | `Assoc ((loc, `List routing_table)::xs) ->
      let loc_filter = parse_location_to_pred loc (header_placement Loc man) false man in
        let action = parse_local_routing_table loc routing_table man in
         OrP (AndP (Binary (loc_filter,True), action), parse_global_routing_table (`Assoc xs) man)
  | `List []
  | `Assoc [] -> Binary (False,False)
  | _ -> failwith "Unexpected JSON format for routing table, please check the json generated by the batfish is in orient format of 'Record'"        

let parse_start_interface_to_pred (man:man) (start_list:string list) : pred =
  List.fold_left (fun acc loc ->
    let (loc,interface) = Scanf.sscanf loc "%[^[][%[^]]" (fun a b -> (a, b)) in
    let start_loc = parse_location_to_pred loc (header_placement Loc man) false man in
    let interface_filter = fst (DStringMap.find (loc, interface) man.interface) in
    Or (acc, And (start_loc, interface_filter))
  ) False start_list
  
let parse_start_loc_to_pred (man:man) (start_list:string list) : pred =
  List.fold_left (fun acc loc ->
    let start_loc = parse_location_to_pred loc (header_placement Loc man) false man in
    Or (acc, start_loc)
  ) False start_list

let parse_end_loc_to_pred (man:man) (end_list:string list) : pred =
  List.fold_left (fun acc loc ->
    let end_loc = parse_location_to_pred loc (header_placement Loc man) false man in
    Or (acc, end_loc)
  ) False end_list

let parse_end_interface_to_pred (man:man) (end_list:string list) : pred =
  List.fold_left (fun acc loc ->
    let (loc,interface) = Scanf.sscanf loc "%[^[][%[^]]" (fun a b -> (a, b)) in
    let end_loc = parse_location_to_pred loc (header_placement Loc man) false man in
    let interface_filter = snd (DStringMap.find (loc, interface) man.interface) in
    Or (acc, And (end_loc, interface_filter))
  ) False end_list

let json_to_network (table:Yojson.Basic.t) (man:man) (dup_free:bool) (start_list:string list) (end_list:string list): NK.t =
  let routing_table = parse_global_routing_table table man in
  let start_loc = parse_start_interface_to_pred man start_list in
  let end_loc = parse_end_loc_to_pred man end_list in
  let start_filter = AndP (Binary (start_loc,True), Id) in
  let end_filter = AndP (Binary (end_loc,True), Id) in
  let open RN.NK in
  let network = 
    if dup_free then
      Star (Pkr routing_table)
    else
      Star (Seq (Dup,Pkr routing_table)) in
  Seq (Pkr start_filter, Seq (network,Pkr end_filter))

let json_to_network_with_interface (table:Yojson.Basic.t) (man:man) (dup_free:bool) (start_list:string list) (end_list:string list): NK.t =
  let routing_table = parse_global_routing_table table man in
  let start_loc = parse_start_interface_to_pred man start_list in
  let end_loc = parse_end_interface_to_pred man end_list in
  let start_filter = AndP (Binary (start_loc,True), Id) in
  let end_filter = AndP (Binary (end_loc,True), Id) in
  let open RN.NK in
  let network = 
    if dup_free then
      Star (Pkr routing_table)
    else
      Star (Seq (Dup,Pkr routing_table)) in
  Seq (Pkr start_filter, Seq (network,Pkr end_filter))

let json_to_network_with_loc (table:Yojson.Basic.t) (man:man) (dup_free:bool) (start_list:string list) (end_list:string list): NK.t =
  let routing_table = parse_global_routing_table table man in
  let start_loc = parse_start_loc_to_pred man start_list in
  let end_loc = parse_end_loc_to_pred man end_list in
  let start_filter = AndP (Binary (start_loc,True), Id) in
  let end_filter = AndP (Binary (end_loc,True), Id) in
  let open RN.NK in
  let network = 
    if dup_free then
      Star (Pkr routing_table)
    else
      Star (Seq (Dup,Pkr routing_table)) in
  Seq (Pkr start_filter, Seq (network,Pkr end_filter))

let parse_src_ip_filter (ip:string) (man:man): pred =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pred (header_placement SrcIp man) mask 31 ip

let parse_dst_ip_filter (ip:string) (man:man): pred =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pred (header_placement DstIp man) mask 31 ip

let parse_tcp_filter (application:string) (man:man): pred =
  let protocol_pred = parse_protocols_to_pred ["TCP"] man in
  let (lo,hi) = if String.equal application "www" then
    (80,80)
  else if String.equal application "ssh" then
    (22,22)
  else if String.equal application "dns" then
    (53,53)
  else if String.equal application "http" then
    (80,80)
  else if String.equal application "https" then
    (443,443)
  else if String.equal application "ftp" then
    (21,21)
  else if String.equal application "smtp" then
    (25,25)
  else if String.equal application "pop3" then
    (110,110)
  else if String.equal application "imap" then
    (143,143)
  else if String.equal application "telnet" then
    (23,23)
  else if String.equal application "rdp" then
    (3389,3389)
  else if String.equal application "vnc" then
    (5900,5900)
  else if String.equal application "smb" then
    (445,445)
  else if String.equal application "ldap" then
    (389,389)
  else if String.equal application "snmp" then
    (161,162) (* SNMP uses both UDP and TCP *)
  else if String.equal application "syslog" then
    (514,514) (* Syslog uses both UDP and TCP *)
  else if String.equal application "ntp" then
    (123,123) (* NTP uses both UDP and TCP *)
  else 
    failwith ("Unknown application: " ^ application) in
  (And (protocol_pred,(And (get_ge_pred (header_placement DstPorts man) 15 lo, get_le_pred (header_placement DstPorts man) 15 hi))))

let parse_dstports_filter (ports:int) (negate:bool) (man:man): pred =
    let pred = binary_to_pred (header_placement DstPorts man) 16 15 ports in
    if negate then
      Neg pred
    else
      pred
