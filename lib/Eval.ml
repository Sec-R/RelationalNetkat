open Yojson.Basic.Util
open RN

(* This module is used to parse the json output of batfish in orient format of 'index' *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)
module EdgesMap = Map.Make(
  struct type t = string * string
    let compare (s1, s2) (s3, s4) =
      match String.compare s1 s3 with
      | 0 -> String.compare s2 s4
      | c -> c
  end) 

module NodesMap = Map.Make(
  struct type t = string
    let compare s1 s2 = String.compare s1 s2
  end)

let insert_edge = EdgesMap.add

let insert_node (key:string) (map:int NodesMap.t) =
  if NodesMap.mem key map then
    map
  else
    NodesMap.add key (2 * (NodesMap.cardinal map)) map
  
let edgesMap_to_string (edges:(string*string)EdgesMap.t) : string =
  let str = ref "" in
  EdgesMap.iter (fun (node1,interface1) (node2,interface2) ->
    str := !str ^ "Edge: " ^ node1 ^ " " ^ interface1 ^ " -> " ^ node2 ^ " " ^ interface2 ^ "\n"
  ) edges;
  !str

let nodesMap_to_string (nodes: int NodesMap.t) : string =
  let str = ref "" in
  NodesMap.iter (fun node id ->
    str := !str ^ "Node: " ^ node ^ " ID: " ^ string_of_int id ^ "\n"
  ) nodes;
  !str

  (*    | `Assoc ((_, `Assoc ([(_ , `Assoc [(_,`String s1); (_,`String s2)]);(_ , `Assoc [(_,`String s3); (_,`String s4)])]))::xs) ->
*)
let parse_edges_to_map (edges:Yojson.Basic.t) : (string*string)EdgesMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let s1 = entry |> member "Interface" |> member "hostname" |> to_string in
        let s2 = entry |> member "Interface" |> member "interface" |> to_string in
        let s3 = entry |> member "Remote_Interface" |> member "hostname" |> to_string in
        let s4 = entry |> member "Remote_Interface" |> member "interface" |> to_string in
        aux (insert_edge (s1, s2) (s3, s4) acc) (`Assoc xs)
    |  _ -> failwith "Unexpected JSON format for edges, please check the json generated by the batfish is in orient format of 'index'"
  in
  aux EdgesMap.empty edges

let parse_nodes_to_map (nodes:Yojson.Basic.t) : int NodesMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let s = entry |> member "Node" |> to_string in
        aux (insert_node s acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for nodes, please check the json generated by the batfish is in orient format of 'index'"
  in
  aux NodesMap.empty nodes

let rec binary_to_pred (start:int) (length:int) (shifter:int) (num:int) : pred =
  match length with
  | 0 -> True (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           Test (start,false)
         else
           Test (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           And (Test (start, false), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)
         else
           And (Test (start, true), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)


let rec binary_to_pkr (start:int) (length:int) (shifter:int) (num:int) : pkr =
  match length with
  | 0 -> Id (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           RightAsgn (start,false)
         else
           RightAsgn (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           Comp (RightAsgn (start, false), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)
         else
           Comp (RightAsgn (start, true), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)

           
let length_of_int (num:int) : int =
  let rec aux n acc =
    if n = 0 then acc
    else aux (n lsr 1) (acc + 1)
  in
  aux num 0           

let parse_location_to_pred (loc:string) (start:int) (local:bool) (nodes: int NodesMap.t) : pred =
  try
    let id = (NodesMap.find loc nodes) + (if local then 1 else 0) in
      let length = 1 + (length_of_int (NodesMap.cardinal nodes)) in
      binary_to_pred start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_location_to_pkr (loc:string) (start:int) (local:bool) (nodes: int NodesMap.t) : pkr =
  try
    let id = (NodesMap.find loc nodes) + (if local then 1 else 0) in
      let length = 1 + (length_of_int (NodesMap.cardinal nodes)) in
      binary_to_pkr start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")
 
let parse_ip_string (ip:string) : int * int =
  Scanf.sscanf ip "%d.%d.%d.%d/%d" (fun a b c d e-> (a lsl 24 + b lsl 16 + c lsl 8 + d,e))

let find_next_loc (loc:string) (interface:string) (edges:(string*string)EdgesMap.t) : string =
  try
    let (node, _) = EdgesMap.find (loc, interface) edges in
    node
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)


let compare_data = (fun (_, entry1) (_, entry2) ->
           let ip1 = entry1 |> member "Network" |> to_string in
           let ip2 = entry2 |> member "Network" |> to_string in
           let (_, mask1) = parse_ip_string ip1 in
           let (_, mask2) = parse_ip_string ip2 in
           let admin_distance1 = entry1 |> member "Admin_Distance" |> to_int in
           let admin_distance2 = entry2 |> member "Admin_Distance" |> to_int in
           let metric1 = entry1 |> member "Metric" |> to_int in
           let metric2 = entry2 |> member "Metric" |> to_int in
           compare (32 - mask1, admin_distance1, metric1) (32 - mask2, admin_distance2, metric2))  

let parse_routing_table (table:Yojson.Basic.t) (nodes: int NodesMap.t) (edges: (string*string)EdgesMap.t) : pkr = 
  match table with
  | `Assoc data ->
      let rec aux (acc:pkr) (filter:pred) = function
        | [] -> acc
        | (_, entry)::xs ->
            let ip = entry |> member "Network" |> to_string in
            let (ip, mask) = parse_ip_string ip in
            let ip_filter = binary_to_pred (1 + (length_of_int (NodesMap.cardinal nodes))) mask 31 ip in
            let loc = entry |> member "Node" |> to_string in
            let loc_filter = parse_location_to_pred loc 0 false nodes in
            let interface = entry |> member "Next_Hop_Interface" |> to_string in
            let next_loc_pkr = 
                  if String.equal interface "local"
                    then parse_location_to_pkr loc 0 true nodes
                    (* Setting the discard the testing interface *)
                  else if (String.equal interface "null_interface" || String.equal interface "Loopback0")
                    then Binary (False,False)
                    (* Neglect the interface sending to nowhere/outside network *)
                  else try (parse_location_to_pkr (find_next_loc loc interface edges) 0 false nodes)
                    with _ -> Binary (False,False) in
            let new_entry_filter = And (ip_filter,loc_filter) in
            let new_entry_action = AndP (Binary (And (Neg filter,new_entry_filter),True), next_loc_pkr) in       
            aux (OrP (acc, new_entry_action)) (Or (filter, new_entry_filter)) xs
      in aux (Binary (False,False)) False (List.sort compare_data data)
   | _ -> failwith "Unexpected JSON format for routing table, please check the json generated by the batfish is in orient format of 'index'" 

let json_to_network (table:Yojson.Basic.t) (nodes: int NodesMap.t) (edges: (string*string)EdgesMap.t) (start_list:string list) (end_list:string list) : NK.t =
  let routing_table = parse_routing_table table nodes edges in
  let start_loc = List.fold_left (fun acc loc ->
    let start_loc = parse_location_to_pred loc 0 false nodes in
    Or (acc, start_loc)
  ) False start_list in
  let end_loc = List.fold_left (fun acc loc ->
    let end_loc = parse_location_to_pred loc 0 true nodes in
    Or (acc, end_loc)
  ) False end_list in
  let start_filter = AndP (Binary (start_loc,True), Id) in
  let end_filter = AndP (Binary (end_loc,True), Id) in
  let open RN.NK in
  let network = Star (Seq (Dup,Pkr routing_table)) in
   Seq (Pkr start_filter, Seq (network,Pkr end_filter))
  