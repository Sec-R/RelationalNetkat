open Yojson.Basic.Util
open RN

(* This module is used to parse the json output of batfish in orient format of 'index' *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)
module DStringMap = Map.Make(
  struct type t = string * string
    let compare (s1, s2) (s3, s4) =
      match String.compare s1 s3 with
      | 0 -> String.compare s2 s4
      | c -> c
  end) 

module StringMap = Map.Make(
  struct type t = string
    let compare s1 s2 = String.compare s1 s2
  end)

module DIntMap = Map.Make(
  struct type t = int * int
    let compare (i1, j1) (i2, j2) =
      match Int.compare i1 i2 with
      | 0 -> Int.compare j1 j2
      | c -> c
  end)  

module StringSet = Set.Make(
  struct type t = string
  let compare = String.compare
  end)


type header =
  | Loc
  | Vrf
  | Protocol
  | SrcIp
  | SrcPorts
  | DstIp
  | DstPorts
  
type man = {
  nodes: int StringMap.t;
  edges: (string*string)DStringMap.t;
  protocols: int StringMap.t;
  interface: (pkr*pkr)DStringMap.t;
  vrf: (int StringMap.t) StringMap.t;
  interface_to_vrf: int DStringMap.t;
  nodes_length: int;
  vrf_length: int;
  protocols_length: int;
  length: int;
}

let insert_edge = DStringMap.add

let insert_node (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (2 * (StringMap.cardinal map)) map

let insert_protocol (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (StringMap.cardinal map) map

let edgesMap_to_string (edges:(string*string)DStringMap.t) : string =
  let str = ref "" in
  DStringMap.iter (fun (node1,interface1) (node2,interface2) ->
    str := !str ^ "Edge: " ^ node1 ^ " " ^ interface1 ^ " -> " ^ node2 ^ " " ^ interface2 ^ "\n"
  ) edges;
  !str

let nodesMap_to_string (nodes: int StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun node id ->
    str := !str ^ "Node: " ^ node ^ " ID: " ^ string_of_int id ^ "\n"
  ) nodes;
  !str

let protocol_map_to_string (protocols: int StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun protocol id ->
    str := !str ^ "Protocol: " ^ protocol ^ " ID: " ^ string_of_int id ^ "\n"
  ) protocols;
  !str

let vrf_map_to_string (vrf_map: (int StringMap.t) StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun node vrf_map ->
    str := !str ^ "Node: " ^ node ^ "\n";
    StringMap.iter (fun vrf id ->
      str := !str ^ "  VRF: " ^ vrf ^ " ID: " ^ string_of_int id ^ "\n"
    ) vrf_map
  ) vrf_map;
  !str  

let interfaces_to_vrf_to_string (interfaces_to_vrf: int DStringMap.t) : string =
  let str = ref "" in
  DStringMap.iter (fun (node, interface) vrf_id ->
    str := !str ^ "Node: " ^ node ^ " Interface: " ^ interface ^ " VRF ID: " ^ string_of_int vrf_id ^ "\n"
  ) interfaces_to_vrf;
  !str

let stringSet_to_string (set:StringSet.t) : string =
  let str = ref "" in
  StringSet.iter (fun s ->
    str := !str ^ s ^ "\n"
  ) set;
  !str  

let parse_edges_to_map (edges:Yojson.Basic.t) : (string*string)DStringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let s1 = entry |> member "Interface" |> member "hostname" |> to_string in
        let s2 = entry |> member "Interface" |> member "interface" |> to_string in
        let s3 = entry |> member "Remote_Interface" |> member "hostname" |> to_string in
        let s4 = entry |> member "Remote_Interface" |> member "interface" |> to_string in
        aux (insert_edge (s1, s2) (s3, s4) acc) (`Assoc xs)
    |  _ -> failwith "Unexpected JSON format for edges, please check the json generated by the batfish is in orient format of 'index'"
  in
  aux DStringMap.empty edges

let parse_nodes_to_map (nodes:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((s, _)::xs) ->
        aux (insert_node s acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for nodes, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux StringMap.empty nodes

let insert_vrf (node:string) (vrf:string) (map:(int StringMap.t) StringMap.t) : (int StringMap.t) StringMap.t =
  if StringMap.mem node map then
    let vrf_map = StringMap.find node map in
    if StringMap.mem vrf vrf_map then
      map
    else
      StringMap.add node (StringMap.add vrf (StringMap.cardinal vrf_map) vrf_map) map
  else
    StringMap.add node (StringMap.singleton vrf 0) map  

let parse_vrf_to_map (protocols:Yojson.Basic.t) : (int StringMap.t) StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let structure_type = entry |> member "Structure_Type" |> to_string in
        if String.equal structure_type "VRF" then
          let node = entry |> member "Node" |> to_string in
          let vrf = entry |> member "Structure_Name" |> to_string in
          aux (insert_vrf node vrf acc) (`Assoc xs)
        else
          aux acc (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for VRFs, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux StringMap.empty protocols



let parse_protocols_to_map (protocols:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        if String.equal (entry |> member "Structure_Type" |> to_string) "IP_Access_List" then
          let protocols = [entry] |> filter_member "Structure_Definition" |> filter_member "lines" |> flatten |> filter_member "matchCondition" |> filter_member "headerSpace" |> filter_member "ipProtocols" |> flatten |> filter_string  in
          aux (List.fold_left (fun acc proto -> insert_protocol proto acc) acc protocols) (`Assoc xs)
        else
          aux acc (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux (StringMap.singleton "TCP" 0) protocols

let get_filter_name (filter:Yojson.Basic.t) : string =
  match filter with
  | `Null -> ""
  | `String s -> s
  | _ -> failwith "Unexpected JSON format for filter, please check the json generated by the batfish is in orient format of 'record'"  

let parse_interfaces_to_map (interfaces:Yojson.Basic.t) : (string*string)DStringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, table)::xs) ->
        let income_filter = table |> member "Incoming_Filter_Name" |> get_filter_name in
        let outgoing_filter = table |> member "Outgoing_Filter_Name" |> get_filter_name in
        let node = table |> member "Interface" |> member "hostname" |> to_string in
        let interface = table |> member "Interface" |> member "interface" |> to_string in
        aux (insert_edge (node, interface) (income_filter, outgoing_filter) acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for interfaces, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux DStringMap.empty interfaces

(* The length of an integer in bits *)

let length_of_int (num:int) : int =
  let rec aux n acc =
    if n = 0 then acc
    else aux (n lsr 1) (acc + 1)
  in
  aux (num + 1) 0

let get_vrf_length (vrfs:(int StringMap.t) StringMap.t) : int =
  let max_cardinal = StringMap.fold (fun _ vrf_map acc ->
    let cardinal = StringMap.cardinal vrf_map in
    if cardinal > acc then cardinal else acc
  ) vrfs 0 in
  length_of_int max_cardinal

let get_field_length (man:man) : int =
  man.length
  (* nodes dstip dstports srcip protocol *)

(* Convert a binary number to a predicate *)  
let rec binary_to_pred (start:int) (length:int) (shifter:int) (num:int) : pred =
  match length with
  | 0 -> True (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           Test (start,false)
         else
           Test (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           And (Test (start, false), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)
         else
           And (Test (start, true), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)

let rec binary_to_pkr (start:int) (length:int) (shifter:int) (num:int) : pkr =
  match length with
  | 0 -> Id (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           RightAsgn (start,false)
         else
           RightAsgn (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           Comp (RightAsgn (start, false), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)
         else
           Comp (RightAsgn (start, true), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)

          
let header_placement (header:header) (man: man) : int =
  match header with
  | Loc -> 0
  | Vrf -> man.nodes_length
  | Protocol -> man.nodes_length + man.vrf_length
  | DstIp -> man.nodes_length + man.vrf_length + man.protocols_length
  | DstPorts -> 32 + man.nodes_length + man.vrf_length + man.protocols_length
  | SrcIp -> 48 + man.nodes_length + man.vrf_length + man.protocols_length
  | SrcPorts -> 80 + man.nodes_length + man.vrf_length + man.protocols_length

let partial_header_placement (header:header) (node_length: int) (vrf_length: int) (protocol_length: int) : int =
  match header with
  | Loc -> 0
  | Vrf -> node_length
  | Protocol -> node_length + vrf_length
  | DstIp -> node_length + vrf_length + protocol_length
  | DstPorts -> 32 + (node_length + vrf_length + protocol_length)
  | SrcIp -> 48 + (node_length + vrf_length + protocol_length)
  | SrcPorts -> 80 + (node_length + vrf_length + protocol_length)


let parse_protocols_to_pred (protocols:string list) (man:man) : pred =
  let rec aux acc = function
    | [] -> acc
    | x::xs ->
        let id = StringMap.find x man.protocols in
        let protocol_length = man.protocols_length in
        aux (Or (acc, binary_to_pred (header_placement Protocol man) protocol_length (protocol_length-1) id)) xs
  in
  if List.length protocols = 0 then
    True
  else
    aux False protocols

let partial_parse_protocols_to_pred (protocols:string list) (protocol_map:int StringMap.t) (node_length:int) (vrf_length:int)  : pred =
  let rec aux acc = function
    | [] -> acc
    | x::xs ->
        let id = StringMap.find x protocol_map in
        let protocol_length = length_of_int (StringMap.cardinal protocol_map) in
        aux (Or (acc, binary_to_pred (partial_header_placement Protocol node_length vrf_length protocol_length) protocol_length (protocol_length-1) id)) xs
  in
  if List.length protocols = 0 then
    True
  else
    aux False protocols


let parse_location_to_pred (loc:string) (local:bool) (man: man) : pred =
  try
    let id = (StringMap.find loc man.nodes) + (if local then 1 else 0) in
      let length = man.nodes_length in
      binary_to_pred (header_placement Loc man) length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_location_to_pkr (loc:string) (local:bool) (man: man) : pkr =
  try
    let id = (StringMap.find loc man.nodes) + (if local then 1 else 0) in
      let length = man.nodes_length in
      binary_to_pkr (header_placement Loc man) length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_vrf_to_pred (vrf_id:int) (man: man) : pred =
  let length = man.vrf_length in
  binary_to_pred (header_placement Vrf man) length (length-1) vrf_id

let parse_vrf_to_pkr (vrf_id:int) (man: man) : pkr =
  let length = man.vrf_length in
  binary_to_pkr (header_placement Vrf man) length (length-1) vrf_id

let parse_ip_entry_string (ip:string) : int * int =
  Scanf.sscanf ip "%d.%d.%d.%d/%d" (fun a b c d e-> (a lsl 24 + b lsl 16 + c lsl 8 + d,e))

let parse_ip_string (ip:string) : int =
  Scanf.sscanf ip "%d.%d.%d.%d" (fun a b c d-> a lsl 24 + b lsl 16 + c lsl 8 + d)  

let find_next_loc (loc:string) (interface:string) (man: man) : string =
  try
    let (node, _) = DStringMap.find (loc, interface) man.edges in
    node
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)

let find_next_loc_and_interface (loc:string) (interface:string) (man: man) : string*string =
  DStringMap.find (loc, interface) man.edges
 

let find_next_loc_filter (loc:string) (interface:string) (man: man) : pkr =
  try
    fst (DStringMap.find (DStringMap.find (loc, interface) man.edges) man.interface)
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)

let match_ip_string (ip1:int) (ip2:int) (mask:int) : bool =
  let mask = 0xFFFFFFFF lsl (32 - mask) in
  ip1 land mask = ip2 land mask

let compare_data = (fun entry1 entry2 ->
           let ip1 = entry1 |> member "Network" |> to_string in
           let ip2 = entry2 |> member "Network" |> to_string in
           let (_, mask1) = parse_ip_entry_string ip1 in
           let (_, mask2) = parse_ip_entry_string ip2 in
           compare mask2 mask1
         )

let parse_ip_wildcard (ip:string) : int * int =
  if String.contains ip '/' then
    parse_ip_entry_string ip
  else
    (parse_ip_string ip, 32)

let rec get_ge_pred (start:int) (shifter:int) (number:int) : pred =
  if shifter = 0 then
    if number land 1 = 0 then
      True
    else
      Test (start, true)
  else
    if (number lsr shifter) land 1 = 0 then
      Or (Test (start, true), get_ge_pred (start + 1) (shifter - 1) number)
    else
      And (Test (start, true), get_ge_pred (start + 1) (shifter - 1) number)

let rec get_le_pred (start:int) (shifter:int) (number:int) : pred =
  if shifter = 0 then
    if number land 1 = 1 then
      True
    else
      Test (start, false)
  else
    if (number lsr shifter) land 1 = 1 then
      Or (Test (start, false), get_le_pred (start + 1) (shifter - 1) number)
    else
      And (Test (start, false), get_le_pred (start + 1) (shifter - 1) number)

let rec parse_ports (ports:Yojson.Basic.t) (nodes_length:int) (vrf_length:int) (protocol_length:int) (dst:bool): pred =
  match ports with
  | `List ((`String s)::xs) ->
      let (lo,hi) = Scanf.sscanf s "%d-%d" (fun a b -> (a, b)) in
      let ge_lo_pred = get_ge_pred (partial_header_placement (if dst then DstPorts else SrcPorts) nodes_length vrf_length protocol_length) 15 lo in
      let le_hi_pred = get_le_pred (partial_header_placement (if dst then DstPorts else SrcPorts) nodes_length vrf_length protocol_length) 15 hi in
      let ports_pred = And (ge_lo_pred, le_hi_pred) in
      Or (ports_pred, parse_ports (`List xs) nodes_length vrf_length protocol_length dst)
  | `List [] -> False
  | _ -> failwith "Unexpected JSON format for ports, please check the json generated by the batfish is in orient format of 'record'"
  
let string_of_ip (ip:int) : string =
  let a = (ip lsr 24) land 0xFF in
  let b = (ip lsr 16) land 0xFF in
  let c = (ip lsr 8) land 0xFF in
  let d = ip land 0xFF in
  Printf.sprintf "%d.%d.%d.%d" a b c d  

let ip_under_mask (ip:int) (mask:int) : int =
  let mask = 0xFFFFFFFF lsl (32 - mask) in
  ip land mask

let rec parse_protocol_filter (node:string) (named_structure:string) (protocols:Yojson.Basic.t) (nodesmap:int StringMap.t) (vrf_length:int) (protocol_map:int StringMap.t): pred =
  if (String.equal named_structure "") then
    True
  else
    let nodes_length = length_of_int (StringMap.cardinal nodesmap) in
    let protocols_length = length_of_int (StringMap.cardinal protocol_map) in
  match protocols with
  | `Assoc ((_, entry)::xs) ->
      let structure_type = entry |> member "Structure_Type" |> to_string in
      let structure_name = entry |> member "Structure_Name" |> to_string in
      let structure_node = entry |> member "Node" |> to_string in
      if (String.equal structure_type "IP_Access_List") && (String.equal structure_name named_structure) && (String.equal structure_node node) then
        let local_entries = entry |> member "Structure_Definition" |> member "lines" |> to_list in
        let rec aux (acc:pred) = function
          | [] -> False
          | x::xs ->
              let action = x |> member "action" |> to_string in
              let accept = if String.equal action "PERMIT" then true else
                if String.equal action "DENY" then false else
                  failwith ("Unexpected action: " ^ action) in
              let src_and_dst_pred = 
                try (let (dstip,dst_mask) = x |> member "matchCondition" |> member "headerSpace" |> member "dstIps" |> member "ipWildcard" |> to_string |> parse_ip_wildcard in
                     let dst_pred = binary_to_pred (partial_header_placement DstIp nodes_length vrf_length protocols_length) dst_mask 31 dstip in
                     let (srcip,src_mask) = x |> member "matchCondition" |> member "headerSpace" |> member "srcIps" |> member "ipWildcard" |> to_string |> parse_ip_wildcard in
                     let src_pred = binary_to_pred (partial_header_placement SrcIp nodes_length vrf_length protocols_length) src_mask 31 srcip in
                     let dstports_pred =
                      try
                       parse_ports (x |> member "matchCondition" |> member "headerSpace" |> member "dstPorts") nodes_length vrf_length protocols_length true
                      with _ -> True in
                     let srcports_pred =
                      try
                       parse_ports (x |> member "matchCondition" |> member "headerSpace" |> member "srcPorts") nodes_length vrf_length protocols_length false
                      with _ -> True in
                     And (And (src_pred, srcports_pred), And (dst_pred, dstports_pred)))
               with _ -> 
                let (src_or_dst_ip, src_or_dst_mask) = 
                  try x |> member "matchCondition" |> member "headerSpace" |> member "srcOrDstIps" |> member "prefix" |> to_string |> parse_ip_wildcard
                  with _ -> (0,0) in
                let src_pred =
                   binary_to_pred (partial_header_placement SrcIp nodes_length vrf_length protocols_length) src_or_dst_mask 31 src_or_dst_ip in
                let dst_pred =
                    binary_to_pred (partial_header_placement DstIp nodes_length vrf_length protocols_length) src_or_dst_mask 31 src_or_dst_ip in
                Or (src_pred, dst_pred) in
              (* Parse the source and destination IPs *)
              let protocol_list = [x] |> filter_member "matchCondition" |> filter_member "headerSpace" |> filter_member "ipProtocols" |> flatten |> filter_string  in
              let protocol_pred = partial_parse_protocols_to_pred protocol_list protocol_map nodes_length vrf_length in
              (* Construct the new filter *)  
              let new_filter =  (And (src_and_dst_pred, protocol_pred)) in
              if accept then
                (* If the action is accept, we combine the new filter with the existing one *)
                (Or (And (Neg acc,new_filter), aux (Or (acc, new_filter)) xs))
              else
                (* If the action is deny, we negate the new filter and combine it with the existing one *)
                aux (Or (acc, new_filter)) xs
        in
        aux False local_entries
      else
        parse_protocol_filter node named_structure (`Assoc xs) nodesmap vrf_length protocol_map
  | `Assoc []  
  | `List [] ->  True
  | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'"

let parse_interface_to_vrf (interfaces:Yojson.Basic.t) (vrf_map:(int StringMap.t) StringMap.t) : int DStringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let node = entry |> member "Interface" |> member "hostname" |> to_string in
        let interface = entry |> member "Interface" |> member "interface" |> to_string in
        let vrf = entry |> member "VRF" |> to_string in
        let vrf_id = StringMap.find vrf (StringMap.find node vrf_map) in
          aux (DStringMap.add (node, interface) vrf_id acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for interfaces, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux DStringMap.empty interfaces

let pred_to_filter (pred:pred):pkr =
  AndP (Binary (True, pred), Id)  

let init_man (nodes:Yojson.Basic.t) (edges:Yojson.Basic.t) (protocols:Yojson.Basic.t) (interfaces:Yojson.Basic.t): man =
  let nodesmap = parse_nodes_to_map nodes in
  let protocol_map = parse_protocols_to_map protocols in
  let vrf_map = parse_vrf_to_map protocols in
  let nodes_length = length_of_int (StringMap.cardinal nodesmap) in
  let vrf_length = get_vrf_length vrf_map in
  let protocols_length = length_of_int (StringMap.cardinal protocol_map) in
  let interfaces_to_vrf = parse_interface_to_vrf interfaces vrf_map in
  let length =   nodes_length + vrf_length + protocols_length + 32 + 16 + 32 + 16 + 1 in
  {
    nodes = nodesmap;
    edges = parse_edges_to_map edges;
    protocols = protocol_map;
    interface = DStringMap.mapi 
      (fun (node,_) (in_filter, out_filter) -> (pred_to_filter (parse_protocol_filter node in_filter protocols nodesmap vrf_length protocol_map), pred_to_filter (parse_protocol_filter node out_filter protocols nodesmap vrf_length protocol_map))
    ) (parse_interfaces_to_map interfaces);
    vrf = vrf_map;
    interface_to_vrf = interfaces_to_vrf;
    nodes_length = nodes_length;
    vrf_length = vrf_length;
    protocols_length = protocols_length;
    length = length;
  }

let post_pred_pkr (pred:pred) (pkr:pkr) : pkr =
  (AndP (Binary (True,pred), pkr))

let post_filter_pkr (filter:pkr) (pkr:pkr) : pkr =
  Comp (pkr, filter)

let parse_local_routing_table (loc:string) (tables: Yojson.Basic.t list)  (man:man) : pkr = 
   let rec aux (re_routing_list: (int*pred) list) (actions:pkr DIntMap.t)  (mask_list:int list) (cur_length:int) (filter:pred) (mask_filter:pred) (routing_table:pkr) (pending_actions:pkr) = function
    | [] -> (re_routing_list, actions, mask_list, OrP (AndP (Binary (Neg filter,True), pending_actions), routing_table))
    | table::xs ->
        let ip = table |> member "Network" |> to_string in
        let (ip, mask) = parse_ip_entry_string ip in
        let ip_filter = binary_to_pred (header_placement DstIp man) mask 31 ip in
        let vrf = table |> member "VRF" |> to_string in
        let vrf_filter = parse_vrf_to_pred (StringMap.find vrf (StringMap.find loc man.vrf)) man in
        let new_filter = And (ip_filter, vrf_filter) in
        let next_mask_list = if mask < cur_length then
          mask_list @ [mask]
        else
          mask_list in
        let next_cur = mask in
        let next_filter = if mask < cur_length then
          Or (filter, mask_filter)
        else
          filter in
        let next_mask_filter = if mask < cur_length then
          new_filter
        else
          Or (mask_filter, new_filter) in
        let next_routing_table = if mask < cur_length then 
          OrP (AndP (Binary (Neg filter,True), pending_actions), routing_table)
        else
          routing_table in
        let next_pending_actions = if mask < cur_length then
          Empty
        else 
          pending_actions in           
        let interface = table |> member "Next_Hop_Interface" |> to_string in
          if String.equal interface "dynamic" then
            let route_ip = table |> member "Next_Hop_IP" |> to_string in
            let route_ip = parse_ip_string route_ip in
            aux (re_routing_list @ [(route_ip, And (Neg filter,new_filter))]) actions next_mask_list next_cur next_filter 
              next_mask_filter next_routing_table next_pending_actions xs
          else let next_loc_pkr = 
                  if String.equal interface "Loopback0"
                    then post_filter_pkr (snd (DStringMap.find (loc, interface) man.interface))
                        (parse_location_to_pkr loc true man)
                    (* Setting the discard the testing interface *)
                  else if String.equal interface "null_interface"
                    then Empty
                    (* Neglect the interface sending to nowhere/outside network *)
                  else try post_filter_pkr (snd (DStringMap.find (loc, interface) man.interface))
                    (post_filter_pkr (find_next_loc_filter loc interface man)
                    (Comp (parse_location_to_pkr (find_next_loc loc interface man) false man,
                      parse_vrf_to_pkr (DStringMap.find (find_next_loc_and_interface loc interface man) man.interface_to_vrf)
                      man)))
                    with _ -> Empty in
            aux re_routing_list (DIntMap.add (mask, ip_under_mask ip mask) next_loc_pkr actions)
              next_mask_list next_cur next_filter next_mask_filter next_routing_table (OrP (AndP (Binary (new_filter,True),next_loc_pkr), next_pending_actions)) xs
    in
  let (re_routing_list, actions, mask_list, routing_table) = aux [] DIntMap.empty [] 33 False False Empty Empty (List.sort compare_data tables) in
    let rec action_lookup (mask_list:int list) (ip:int) : pkr =
      match mask_list with
      | [] -> Empty
      | mask::xs ->
          try (DIntMap.find (mask, ip_under_mask ip mask) actions)
          with Not_found -> action_lookup xs ip
    in
    List.fold_right (fun (ip,pred) acc -> OrP (AndP (Binary (pred,True), action_lookup mask_list ip), acc)) re_routing_list
      routing_table

let rec parse_global_routing_table (table:Yojson.Basic.t) (man:man) : pkr = 
  match table with
  | `Assoc ((loc, `List routing_table)::xs) ->
      let loc_filter = parse_location_to_pred loc false man in
        let action = parse_local_routing_table loc routing_table man in
         OrP (AndP (Binary (loc_filter,True), action), parse_global_routing_table (`Assoc xs) man)
  | `List []
  | `Assoc [] -> Empty
  | _ -> failwith "Unexpected JSON format for routing table, please check the json generated by the batfish is in orient format of 'Record'"        

let parse_start_loc_to_pkr (man:man) (start_list:string list) : pkr =
  List.fold_left (fun acc loc ->
  try 
    let (loc,interface) = Scanf.sscanf loc "%[^[][%[^]]" (fun a b -> (a, b)) in
    let start_loc = parse_location_to_pred loc false man in
    let interface_filter = fst (DStringMap.find (loc, interface) man.interface) in
    OrP (acc, AndP (Binary (start_loc,True), interface_filter))
  with _ ->
    let start_loc = parse_location_to_pred loc false man in
    OrP (acc, pred_to_filter start_loc)
  ) Empty start_list

let parse_end_loc_to_pkr (man:man) (end_list:string list) : pkr =
  List.fold_left (fun acc loc ->
  try 
    let (loc,interface) = Scanf.sscanf loc "%[^[][%[^]]" (fun a b -> (a, b)) in
    let end_loc = parse_location_to_pred loc false man in
    let interface_filter = snd (DStringMap.find (loc, interface) man.interface) in
    OrP (acc, AndP (Binary (end_loc,True), interface_filter))
  with _ ->
    let end_loc = parse_location_to_pred loc false man in
    OrP (acc, pred_to_filter end_loc)
  ) Empty end_list

let json_to_network (table:Yojson.Basic.t) (man:man) (dup_free:bool) (start_list:string list) (end_list:string list): NK.t =
  let routing_table = parse_global_routing_table table man in
  let start_loc = parse_start_loc_to_pkr man start_list in
  let end_loc = parse_end_loc_to_pkr man end_list in
  let open RN.NK in
  let network = 
    if dup_free then
      Star (Pkr routing_table)
    else
      Star (Seq (Dup,Pkr routing_table)) in
  Seq (Pkr start_loc, Seq (network,Pkr end_loc))

let parse_src_ip_filter (ip:string) (man:man): pred =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pred (header_placement SrcIp man) mask 31 ip

let parse_dst_ip_filter (ip:string) (man:man): pred =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pred (header_placement DstIp man) mask 31 ip

let parse_src_ip_pkr (ip:string) (man:man): pkr =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pkr (header_placement SrcIp man) mask 31 ip

let parse_dst_ip_pkr (ip:string) (man:man): pkr =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pkr (header_placement DstIp man) mask 31 ip


let parse_tcp_filter (application:string) (man:man): pred =
  let protocol_pred = parse_protocols_to_pred ["TCP"] man in
  let (lo,hi) = if String.equal application "www" then
    (80,80)
  else if String.equal application "ssh" then
    (22,22)
  else if String.equal application "dns" then
    (53,53)
  else if String.equal application "http" then
    (80,80)
  else if String.equal application "https" then
    (443,443)
  else if String.equal application "ftp" then
    (21,21)
  else if String.equal application "smtp" then
    (25,25)
  else if String.equal application "pop3" then
    (110,110)
  else if String.equal application "imap" then
    (143,143)
  else if String.equal application "telnet" then
    (23,23)
  else if String.equal application "rdp" then
    (3389,3389)
  else if String.equal application "vnc" then
    (5900,5900)
  else if String.equal application "smb" then
    (445,445)
  else if String.equal application "ldap" then
    (389,389)
  else if String.equal application "snmp" then
    (161,162) (* SNMP uses both UDP and TCP *)
  else if String.equal application "syslog" then
    (514,514) (* Syslog uses both UDP and TCP *)
  else if String.equal application "ntp" then
    (123,123) (* NTP uses both UDP and TCP *)
  else 
    failwith ("Unknown application: " ^ application) in
  (And (protocol_pred,(And (get_ge_pred (header_placement DstPorts man) 15 lo, get_le_pred (header_placement DstPorts man) 15 hi))))

let parse_dstports_filter (ports:int) (negate:bool) (man:man): pred =
    let pred = binary_to_pred (header_placement DstPorts man) 16 15 ports in
    if negate then
      Neg pred
    else
      pred

let insert_rela_node (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (StringMap.cardinal map) map

let insert_rela_nodes (keys:string list) (map:int StringMap.t) : int StringMap.t =
  List.fold_left (fun acc key -> insert_rela_node key acc) map keys    

let parse_rela_nodes (rela:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `List [] -> acc
    | `List (entry::xs) ->
        let before_keys_in = entry |> member "graphBefore" |> member "nodeToOutEdgesMap" |> keys in
        let before_keys_out = entry |> member "graphBefore" |> member "nodeToOutEdgesMap" |> values |> List.map keys |> List.flatten in
        let after_keys_in = entry |> member "graphAfter" |> member "nodeToOutEdgesMap" |> keys in
        let after_keys_out = entry |> member "graphAfter" |> member "nodeToOutEdgesMap" |> values |> List.map keys |> List.flatten in
        let before_sources = entry |> member "graphBefore" |> member "sourceNodes" |> to_list |> filter_string in
        let after_sources = entry |> member "graphAfter" |> member "sourceNodes" |> to_list |> filter_string in
        let before_sinks = entry |> member "graphBefore" |> member "sinkNodes" |> to_list |> filter_string in
        let after_sinks = entry |> member "graphAfter" |> member "sinkNodes" |> to_list |> filter_string in
        aux (insert_rela_nodes (before_keys_in @ before_keys_out @ after_keys_in @ after_keys_out @ before_sources @ after_sources @ before_sinks @ after_sinks) acc) (`List xs)
    | _ -> failwith "Unexpected JSON format for rela, please check the json"
  in
  aux StringMap.empty rela

let init_rela_man (rela:Yojson.Basic.t) : man =
  let rela_nodes = parse_rela_nodes rela in
  let nodes_length = length_of_int (StringMap.cardinal rela_nodes) in
  let vrf_length = 0 in (* No VRFs in RELA *)
  let protocols_length = 0 in (* No protocols in RELA *)
  let edges = DStringMap.empty in (* No edges in RELA *)
  let interface = DStringMap.empty in (* No interfaces in RELA *)
  let interface_to_vrf = DStringMap.empty in (* No interfaces to VRF mapping in RELA *)
  let length = nodes_length + 32 + 32 + 1 in
  {
    nodes = rela_nodes;
    edges;
    protocols = StringMap.empty; (* No protocols in RELA *)
    interface;
    vrf = StringMap.empty; (* No VRFs in RELA *)
    interface_to_vrf;
    nodes_length;
    vrf_length;
    protocols_length;
    length;
  }  

let rela_header_placement (header:header) (man: man) : int =
  match header with
  | Loc -> 0
  | SrcIp -> man.nodes_length
  | DstIp -> 32 + man.nodes_length
  | _ -> failwith "RELA does not support Vrf, Protocol, DstPorts, SrcPorts headers"


let parse_rela_location_to_pred (loc:string) (man: man) : pred =
  try
    let id = StringMap.find loc man.nodes in
    let length = man.nodes_length in
    binary_to_pred (rela_header_placement Loc man) length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_rela_location_to_pkr (loc:string) (man: man) : pkr =
  try
    let id = StringMap.find loc man.nodes in
    let length = man.nodes_length in
    binary_to_pkr (rela_header_placement Loc man) length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_rela_src_ip_filter (ip:string) (man:man): pred =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pred (rela_header_placement SrcIp man) mask 31 ip

let parse_rela_dst_ip_filter (ip:string) (man:man): pred =
  let (ip, mask) = parse_ip_wildcard ip in
  binary_to_pred (rela_header_placement DstIp man) mask 31 ip

let parse_rela_local_routing_table (rela:Yojson.Basic.t) (man:man) : NK.t * NK.t =
  let ip_traffic_list = rela |> member "ipTrafficKeys" |> to_list in
    let ip_pred = 
      List.fold_left (fun acc ip ->
        let srcip = ip |> member "srcIp" |> to_string in
        let dstip = ip |> member "dstIp" |> to_string in
        Or (acc, And (parse_rela_src_ip_filter srcip man, parse_rela_dst_ip_filter dstip man))) (False) ip_traffic_list  in
  let before_sink_list = rela |> member "graphBefore" |> member "sinkNodes" |> to_list |> filter_string in
  let before_sink_set = StringSet.of_list before_sink_list in
  let after_sink_list = rela |> member "graphAfter" |> member "sinkNodes" |> to_list |> filter_string in
  let after_sink_set = StringSet.of_list after_sink_list in
  let before_start_list = rela |> member "graphBefore" |> member "sourceNodes" |> to_list |> filter_string in
  let before_start_set = StringSet.of_list before_start_list in
  let after_start_list = rela |> member "graphAfter" |> member "sourceNodes" |> to_list |> filter_string in
  let after_start_set = StringSet.of_list after_start_list in
  let rec aux (acc:pkr) = function
    | `Assoc [] -> acc
    | `Assoc ((loc, table)::xs) ->
          let loc_filter = parse_rela_location_to_pred loc man in
          let next_list = table |> keys in
          let next_pkr = 
            List.fold_left (fun acc next_loc ->
                OrP (acc, AndP (Binary (ip_pred,True),parse_rela_location_to_pkr next_loc man))
            ) Empty next_list in
            if next_pkr = Empty then
              aux acc (`Assoc xs)
            else
              aux (OrP (acc, AndP (Binary (loc_filter,True), next_pkr))) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for rela"
  in
    let before_table = aux Empty (rela |> member "graphBefore" |> member "nodeToOutEdgesMap") in
    let after_table = aux Empty (rela |> member "graphAfter" |> member "nodeToOutEdgesMap") in
    let before_sink_pred = 
      StringSet.fold (fun loc acc -> Or (acc, parse_rela_location_to_pred loc man)) before_sink_set False in
    let after_sink_pred = 
      StringSet.fold (fun loc acc -> Or (acc, parse_rela_location_to_pred loc man)) after_sink_set False in
    let before_start_pred = 
      StringSet.fold (fun loc acc -> Or (acc, parse_rela_location_to_pred loc man)) before_start_set False in
    let after_start_pred = 
      StringSet.fold (fun loc acc -> Or (acc, parse_rela_location_to_pred loc man)) after_start_set False in
    let before_start_filter = AndP (Binary (And (before_start_pred, ip_pred), True), Id) in
    let after_start_filter = AndP (Binary (And (after_start_pred, ip_pred), True), Id) in
    let before_sink_filter = AndP (Binary (before_sink_pred, True), Id) in
    let after_sink_filter = AndP (Binary (after_sink_pred, True), Id) in
      let open RN.NK in
    let before_network = Star (Seq (Pkr before_table, Dup)) in
    let after_network = Star (Seq (Pkr after_table, Dup)) in
    let before_network = Seq (Pkr before_start_filter, Seq (before_network, Pkr before_sink_filter)) in
    let after_network = Seq (Pkr after_start_filter, Seq (after_network, Pkr after_sink_filter)) in
    (before_network, after_network)


let parse_rela_global_routing_table (rela:Yojson.Basic.t) (man:man) : NK.t * NK.t =
  let rec aux (rela:Yojson.Basic.t) =
    match rela with
    | `List [] -> (SNK.empty, SNK.empty)
    | `List (entry::xs) ->
        let (before_network, after_network) = parse_rela_local_routing_table entry man in
        (* Recursively parse the rest of the entries *)
        let (acc_before_network, acc_after_network) = aux (`List xs) in
        (SNK.add before_network acc_before_network, SNK.add after_network acc_after_network)
  | _ -> failwith "Unexpected JSON format for rela"
    in
    let (before_set, after_set) = aux rela in
    (* Convert the sets to networks *)
    (Union before_set, Union after_set)

let rela_to_network (rela:Yojson.Basic.t) (man:man) : NK.t * NK.t =
  parse_rela_global_routing_table rela man
  
let parse_internet_gateways (internet_gateways:Yojson.Basic.t): StringSet.t =
  internet_gateways |> member "InternetGateways" |> to_list |> filter_member "InternetGatewayId" |> filter_string |> StringSet.of_list 

let add_ip_switches (ip_switches:Yojson.Basic.t) (gateways:StringSet.t) (man:man): man =
  let rec aux acc = function
    | `List [] -> acc
    | `List (entry::xs) ->
        (try let public_ip = entry |> member "Association" |> member "PublicIp" |> to_string in
            let private_ip = entry |> member "PrivateIpAddress" |> to_string in
            let private_srcip_filter = parse_src_ip_filter private_ip man in
            let public_dstip_filter = parse_dst_ip_filter public_ip man in
            let public_srcip_pkr = parse_src_ip_pkr public_ip man in
            let private_dstip_pkr = parse_dst_ip_pkr private_ip man in
            let src_ip_switcher = OrP (AndP (Binary (private_srcip_filter,True), public_srcip_pkr),
               AndP (Binary (Neg private_srcip_filter,True),Id)) in
            let dst_ip_switcher = OrP (AndP (Binary (public_dstip_filter,True), private_dstip_pkr),
               AndP (Binary (Neg public_dstip_filter,True),Id)) in  
            let interface = man.interface in
            let new_interface = DStringMap.mapi (fun (node, interface_name) (in_filter, out_filter) ->
              if String.equal interface_name "backbone" && StringSet.mem node gateways then
                (Comp (in_filter, dst_ip_switcher), Comp (out_filter, src_ip_switcher))
              else
                (in_filter, out_filter)
            ) interface in
             aux {acc with interface = new_interface} (`List xs)
        with
        | _ -> aux acc (`List xs))
    | _ -> failwith "Unexpected JSON format for IP switches, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux man (ip_switches |> member "NetworkInterfaces")