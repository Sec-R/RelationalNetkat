open Yojson.Basic.Util
open RN

(* This module is used to parse the json output of batfish in orient format of 'index' *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)
module EdgesMap = Map.Make(
  struct type t = string * string
    let compare (s1, s2) (s3, s4) =
      match String.compare s1 s3 with
      | 0 -> String.compare s2 s4
      | c -> c
  end) 

module StringMap = Map.Make(
  struct type t = string
    let compare s1 s2 = String.compare s1 s2
  end)

type header =
  | Loc
  | SrcIp
  | DstIp
  | Protocol
  
type man = {
  nodes: int StringMap.t;
  edges: (string*string)EdgesMap.t;
  protocols: int StringMap.t;
}

let insert_edge = EdgesMap.add

let insert_node (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (2 * (StringMap.cardinal map)) map

let insert_protocol (key:string) (map:int StringMap.t) =
  if StringMap.mem key map then
    map
  else
    StringMap.add key (StringMap.cardinal map) map

let edgesMap_to_string (edges:(string*string)EdgesMap.t) : string =
  let str = ref "" in
  EdgesMap.iter (fun (node1,interface1) (node2,interface2) ->
    str := !str ^ "Edge: " ^ node1 ^ " " ^ interface1 ^ " -> " ^ node2 ^ " " ^ interface2 ^ "\n"
  ) edges;
  !str

let nodesMap_to_string (nodes: int StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun node id ->
    str := !str ^ "Node: " ^ node ^ " ID: " ^ string_of_int id ^ "\n"
  ) nodes;
  !str

let protocol_map_to_string (protocols: int StringMap.t) : string =
  let str = ref "" in
  StringMap.iter (fun protocol id ->
    str := !str ^ "Protocol: " ^ protocol ^ " ID: " ^ string_of_int id ^ "\n"
  ) protocols;
  !str



let parse_edges_to_map (edges:Yojson.Basic.t) : (string*string)EdgesMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let s1 = entry |> member "Interface" |> member "hostname" |> to_string in
        let s2 = entry |> member "Interface" |> member "interface" |> to_string in
        let s3 = entry |> member "Remote_Interface" |> member "hostname" |> to_string in
        let s4 = entry |> member "Remote_Interface" |> member "interface" |> to_string in
        aux (insert_edge (s1, s2) (s3, s4) acc) (`Assoc xs)
    |  _ -> failwith "Unexpected JSON format for edges, please check the json generated by the batfish is in orient format of 'index'"
  in
  aux EdgesMap.empty edges

let parse_nodes_to_map (nodes:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((s, _)::xs) ->
        aux (insert_node s acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for nodes, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux StringMap.empty nodes

let parse_protocols_to_map (protocols:Yojson.Basic.t) : int StringMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        if String.equal (entry |> member "Structure_Type" |> to_string) "IP_Access_List" then
          let protocols = [entry] |> filter_member "Structure_Definition" |> filter_member "lines" |> flatten |> filter_member "matchCondition" |> filter_member "headerSpace" |> filter_member "ipProtocols" |> flatten |> filter_string  in
          aux (List.fold_left (fun acc proto -> insert_protocol proto acc) acc protocols) (`Assoc xs)
        else
          aux acc (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux StringMap.empty protocols

let length_of_int (num:int) : int =
  let rec aux n acc =
    if n = 0 then acc
    else aux (n lsr 1) (acc + 1)
  in
  aux (num + 1) 0


let init_man (nodes:Yojson.Basic.t) (edges:Yojson.Basic.t) (protocols:Yojson.Basic.t) : man =
  {
    nodes = parse_nodes_to_map nodes;
    edges = parse_edges_to_map edges;
    protocols = parse_protocols_to_map protocols;
  }

let get_field_length (man:man) : int =
  let nodes_length = length_of_int (StringMap.cardinal man.nodes) in
  let protocols_length = length_of_int (StringMap.cardinal man.protocols) in
  nodes_length + 32 + 32 + protocols_length + 1

(* Convert a binary number to a predicate *)  
let rec binary_to_pred (start:int) (length:int) (shifter:int) (num:int) : pred =
  match length with
  | 0 -> True (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           Test (start,false)
         else
           Test (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           And (Test (start, false), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)
         else
           And (Test (start, true), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)

let rec binary_to_pkr (start:int) (length:int) (shifter:int) (num:int) : pkr =
  match length with
  | 0 -> Id (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           RightAsgn (start,false)
         else
           RightAsgn (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           Comp (RightAsgn (start, false), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)
         else
           Comp (RightAsgn (start, true), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)

          
let header_placement (header:header) (man: man) : int =
  match header with
  | Loc -> 0
  | DstIp -> length_of_int (StringMap.cardinal man.nodes)
  | SrcIp -> 32 + (length_of_int (StringMap.cardinal man.nodes))
  | Protocol -> 64 + (length_of_int (StringMap.cardinal man.nodes))


let parse_protocols_to_pred (protocols:string list) (man:man) : pred =
  let rec aux acc = function
    | [] -> acc
    | x::xs ->
        let id = StringMap.find x man.protocols in
        let protocol_length = length_of_int (StringMap.cardinal man.protocols) in
        aux (Or (acc, binary_to_pred (header_placement Protocol man) protocol_length (protocol_length-1) id)) xs
  in
  if List.length protocols = 0 then
    True
  else
    aux False protocols

let parse_location_to_pred (loc:string) (start:int) (local:bool) (man: man) : pred =
  try
    let id = (StringMap.find loc man.nodes) + (if local then 1 else 0) in
      let length = length_of_int (StringMap.cardinal man.nodes) in
      binary_to_pred start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_location_to_pkr (loc:string) (start:int) (local:bool) (man: man) : pkr =
  try
    let id = (StringMap.find loc man.nodes) + (if local then 1 else 0) in
      let length = length_of_int (StringMap.cardinal man.nodes) in
      binary_to_pkr start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")
 
let parse_ip_entry_string (ip:string) : int * int =
  Scanf.sscanf ip "%d.%d.%d.%d/%d" (fun a b c d e-> (a lsl 24 + b lsl 16 + c lsl 8 + d,e))

let parse_ip_string (ip:string) : int =
  Scanf.sscanf ip "%d.%d.%d.%d" (fun a b c d-> a lsl 24 + b lsl 16 + c lsl 8 + d)  

let find_next_loc (loc:string) (interface:string) (man: man) : string =
  try
    let (node, _) = EdgesMap.find (loc, interface) man.edges in
    node
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)
           
let match_ip_string (ip1:int) (ip2:int) (mask:int) : bool =
  let mask = 0xFFFFFFFF lsl (32 - mask) in
  ip1 land mask = ip2 land mask

let compare_data = (fun entry1 entry2 ->
           let ip1 = entry1 |> member "Network" |> to_string in
           let ip2 = entry2 |> member "Network" |> to_string in
           let (_, mask1) = parse_ip_entry_string ip1 in
           let (_, mask2) = parse_ip_entry_string ip2 in
           compare mask2 mask1
         )

let parse_ip_wildcard (ip:string) : int * int =
  if String.contains ip '/' then
    parse_ip_entry_string ip
  else
    (parse_ip_string ip, 0)

let rec parse_protocol_filter (node:string) (named_structure:string) (protocols:Yojson.Basic.t) (man:man) : pred =
  match protocols with
  | `Assoc ((_, entry)::xs) ->
      let structure_type = entry |> member "Structure_Type" |> to_string in
      let structure_name = entry |> member "Structure_Name" |> to_string in
      let structure_node = entry |> member "Node" |> to_string in
      if (String.equal structure_type "IP_Access_List") && (String.equal structure_name named_structure) && (String.equal structure_node node) then
        let local_entries = entry |> member "Structure_Definition" |> member "lines" in
        let rec aux (acc:pred) = function
          | `List [] -> False
          | `List (x::xs) ->
              let (dstip,dst_mask) = x |> member "matchCondition" |> member "headerSpace" |> member "dstIps" |> member "ipWildcard" |> to_string |> parse_ip_wildcard in
              let dst_pred = binary_to_pred (header_placement DstIp man) dst_mask 31 dstip in
              let (srcip,src_mask) = x |> member "matchCondition" |> member "headerSpace" |> member "srcIps" |> member "ipWildcard" |> to_string |> parse_ip_wildcard in
              let src_pred = binary_to_pred (header_placement SrcIp man) src_mask 31 srcip in
              let protocol_list = [x] |> filter_member "matchCondition" |> filter_member "headerSpace" |> filter_member "ipProtocols" |> filter_string  in
              let protocol_pred = parse_protocols_to_pred protocol_list man in
              let new_filter =  (And (And (src_pred, dst_pred), protocol_pred)) in
              (Or (And (Neg acc,new_filter), aux (Or (acc, new_filter)) (`List xs)))
          | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'" 
        in
        aux False local_entries
      else
        parse_protocol_filter node named_structure (`Assoc xs) man
  | `Assoc [] ->  failwith "Expected interface not found!"
  | `List [] ->  failwith "Expected interface not found!"
  | _ -> failwith "Unexpected JSON format for protocols, please check the json generated by the batfish is in orient format of 'record'"



let parse_local_routing_table (loc:string) (tables: Yojson.Basic.t list)  (man:man) : pkr = 
   let rec aux (re_routing_list: (int*pred) list) (action_list:(int*int*pred*pkr) list) (filter:pred) = function
    | [] -> (re_routing_list, action_list)
    | table::xs ->
        let ip = table |> member "Network" |> to_string in
        let (ip, mask) = parse_ip_entry_string ip in
        let ip_filter = binary_to_pred (header_placement DstIp man) mask 31 ip in
        let interface = table |> member "Next_Hop_Interface" |> to_string in
          if String.equal interface "dynamic" then
            let route_ip = table |> member "Next_Hop_IP" |> to_string in
            let route_ip = parse_ip_string route_ip in
            aux (re_routing_list @ [(route_ip, And (Neg filter,ip_filter))]) action_list (Or (filter, ip_filter)) xs
          else let next_loc_pkr = 
                  if String.equal interface "Loopback0"
                    then parse_location_to_pkr loc (header_placement Loc man) true man
                    (* Setting the discard the testing interface *)
                  else if String.equal interface "null_interface" 
                    then Binary (False,False)
                    (* Neglect the interface sending to nowhere/outside network *)
                  else try (parse_location_to_pkr (find_next_loc loc interface man) (header_placement Loc man) false man)
                    with _ -> Binary (False,False) in
            aux re_routing_list (action_list @ [(ip,mask, And (Neg filter,ip_filter), next_loc_pkr)]) (Or (filter, ip_filter)) xs
    in
  let (re_routing_list, action_list) = aux [] [] False (List.sort compare_data tables) in
    let rec action_lookup (action_list:(int*int*pred*pkr) list) (ip:int) : pkr =
      match action_list with
      | [] -> Binary (False,False)
      | (ip2,mask,_,action)::xs ->
          if match_ip_string ip ip2 mask then
            action
          else action_lookup xs ip
    in
    List.fold_right (fun (ip,pred) acc -> OrP (AndP (Binary (pred,True), action_lookup action_list ip), acc)) re_routing_list
      (List.fold_right (fun (_,_,pred,action) acc -> OrP (AndP (Binary (pred,True), action), acc)) action_list (Binary (False,False)))

let rec parse_global_routing_table (table:Yojson.Basic.t) (man:man) : pkr = 
  match table with
  | `Assoc ((loc, `List routing_table)::xs) ->
      let loc_filter = parse_location_to_pred loc (header_placement Loc man) false man in
        let action = parse_local_routing_table loc routing_table man in
         OrP (AndP (Binary (loc_filter,True), action), parse_global_routing_table (`Assoc xs) man)
  | `List []
  | `Assoc [] -> Binary (False,False)
  | _ -> failwith "Unexpected JSON format for routing table, please check the json generated by the batfish is in orient format of 'Record'"        

let json_to_network (table:Yojson.Basic.t) (man:man) (dup_free:bool) (start_list:string list) (end_list:string list): NK.t =
  let routing_table = parse_global_routing_table table man in
  let start_loc = List.fold_left (fun acc loc ->
    let start_loc = parse_location_to_pred loc (header_placement Loc man) false man in
    Or (acc, start_loc)
  ) False start_list in
  let end_loc = List.fold_left (fun acc loc ->
    let end_loc = parse_location_to_pred loc (header_placement Loc man) false man in
    Or (acc, end_loc)
  ) False end_list in
  let start_filter = AndP (Binary (start_loc,True), Id) in
  let end_filter = AndP (Binary (end_loc,True), Id) in
  let open RN.NK in
  let network = 
    if dup_free then
      Star (Pkr routing_table)
    else
      Star (Seq (Dup,Pkr routing_table)) in
  Seq (Pkr start_filter, Seq (network,Pkr end_filter))
