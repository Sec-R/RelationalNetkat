open Yojson.Basic.Util
open RN

(* This module is used to parse the json output of batfish in orient format of 'index' *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)

(* The json output of batfish in orient format of 'index' is a list of edges and nodes.
   Each edge is a tuple of (node1, interface1) and (node2, interface2).
   Each node is a string. *)
module EdgesMap = Map.Make(
  struct type t = string * string
    let compare (s1, s2) (s3, s4) =
      match String.compare s1 s3 with
      | 0 -> String.compare s2 s4
      | c -> c
  end) 

module NodesMap = Map.Make(
  struct type t = string
    let compare s1 s2 = String.compare s1 s2
  end)

type header =
  | Loc
  | Ip
  
let insert_edge = EdgesMap.add

let insert_node (key:string) (map:int NodesMap.t) =
  if NodesMap.mem key map then
    map
  else
    NodesMap.add key (2 * (NodesMap.cardinal map)) map
  
let edgesMap_to_string (edges:(string*string)EdgesMap.t) : string =
  let str = ref "" in
  EdgesMap.iter (fun (node1,interface1) (node2,interface2) ->
    str := !str ^ "Edge: " ^ node1 ^ " " ^ interface1 ^ " -> " ^ node2 ^ " " ^ interface2 ^ "\n"
  ) edges;
  !str

let nodesMap_to_string (nodes: int NodesMap.t) : string =
  let str = ref "" in
  NodesMap.iter (fun node id ->
    str := !str ^ "Node: " ^ node ^ " ID: " ^ string_of_int id ^ "\n"
  ) nodes;
  !str

  (*    | `Assoc ((_, `Assoc ([(_ , `Assoc [(_,`String s1); (_,`String s2)]);(_ , `Assoc [(_,`String s3); (_,`String s4)])]))::xs) ->
*)
let parse_edges_to_map (edges:Yojson.Basic.t) : (string*string)EdgesMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((_, entry)::xs) ->
        let s1 = entry |> member "Interface" |> member "hostname" |> to_string in
        let s2 = entry |> member "Interface" |> member "interface" |> to_string in
        let s3 = entry |> member "Remote_Interface" |> member "hostname" |> to_string in
        let s4 = entry |> member "Remote_Interface" |> member "interface" |> to_string in
        aux (insert_edge (s1, s2) (s3, s4) acc) (`Assoc xs)
    |  _ -> failwith "Unexpected JSON format for edges, please check the json generated by the batfish is in orient format of 'index'"
  in
  aux EdgesMap.empty edges

let parse_nodes_to_map (nodes:Yojson.Basic.t) : int NodesMap.t =
  let rec aux acc = function
    | `Assoc [] -> acc
    | `Assoc ((s, _)::xs) ->
        aux (insert_node s acc) (`Assoc xs)
    | _ -> failwith "Unexpected JSON format for nodes, please check the json generated by the batfish is in orient format of 'record'"
  in
  aux NodesMap.empty nodes

let rec binary_to_pred (start:int) (length:int) (shifter:int) (num:int) : pred =
  match length with
  | 0 -> True (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           Test (start,false)
         else
           Test (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           And (Test (start, false), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)
         else
           And (Test (start, true), binary_to_pred (start + 1) (length - 1) (shifter - 1) num)


let rec binary_to_pkr (start:int) (length:int) (shifter:int) (num:int) : pkr =
  match length with
  | 0 -> Id (* Invoked by netmask = 0, suggesting not bound by anything *)
  | 1 -> if (num lsr shifter) land 1 = 0 then
           RightAsgn (start,false)
         else
           RightAsgn (start,true)
  | _ -> if (num lsr shifter) land 1 = 0 then
           Comp (RightAsgn (start, false), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)
         else
           Comp (RightAsgn (start, true), binary_to_pkr (start + 1) (length - 1) (shifter - 1) num)

           
let length_of_int (num:int) : int =
  let rec aux n acc =
    if n = 0 then acc
    else aux (n lsr 1) (acc + 1)
  in
  aux num 0           

let header_placement (header:header) (nodes: int NodesMap.t) : int =
  match header with
  | Loc -> 0
  | Ip -> 1 + (length_of_int (NodesMap.cardinal nodes))

let parse_location_to_pred (loc:string) (start:int) (local:bool) (nodes: int NodesMap.t) : pred =
  try
    let id = (NodesMap.find loc nodes) + (if local then 1 else 0) in
      let length = 1 + (length_of_int (NodesMap.cardinal nodes)) in
      binary_to_pred start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")

let parse_location_to_pkr (loc:string) (start:int) (local:bool) (nodes: int NodesMap.t) : pkr =
  try
    let id = (NodesMap.find loc nodes) + (if local then 1 else 0) in
      let length = 1 + (length_of_int (NodesMap.cardinal nodes)) in
      binary_to_pkr start length (length-1)  id
  with Not_found -> failwith ("Node " ^ loc ^ " not found in the map")
 
let parse_ip_entry_string (ip:string) : int * int =
  Scanf.sscanf ip "%d.%d.%d.%d/%d" (fun a b c d e-> (a lsl 24 + b lsl 16 + c lsl 8 + d,e))

let parse_ip_string (ip:string) : int =
  Scanf.sscanf ip "%d.%d.%d.%d" (fun a b c d-> a lsl 24 + b lsl 16 + c lsl 8 + d)  

let find_next_loc (loc:string) (interface:string) (edges:(string*string)EdgesMap.t) : string =
  try
    let (node, _) = EdgesMap.find (loc, interface) edges in
    node
  with Not_found -> failwith ("Interface " ^ interface ^ " not found in the map for node " ^ loc)
           
let match_ip_string (ip1:int) (ip2:int) (mask:int) : bool =
  let mask = 0xFFFFFFFF lsl (32 - mask) in
  ip1 land mask = ip2 land mask

let compare_data = (fun entry1 entry2 ->
           let ip1 = entry1 |> member "Network" |> to_string in
           let ip2 = entry2 |> member "Network" |> to_string in
           let (_, mask1) = parse_ip_entry_string ip1 in
           let (_, mask2) = parse_ip_entry_string ip2 in
           compare mask2 mask1
         )  

let parse_local_routing_table (loc:string) (tables: Yojson.Basic.t list)  (nodes: int NodesMap.t) (edges: (string*string)EdgesMap.t) : pkr = 
   let rec aux (re_routing_list: (int*pred) list) (action_list:(int*int*pred*pkr) list) (filter:pred) = function
    | [] -> (re_routing_list, action_list)
    | table::xs ->
        let ip = table |> member "Network" |> to_string in
        let (ip, mask) = parse_ip_entry_string ip in
        let ip_filter = binary_to_pred (header_placement Ip nodes) mask 31 ip in
        let interface = table |> member "Next_Hop_Interface" |> to_string in
          if String.equal interface "dynamic" then
            let route_ip = table |> member "Next_Hop_IP" |> to_string in
            let route_ip = parse_ip_string route_ip in
            aux (re_routing_list @ [(route_ip, And (Neg filter,ip_filter))]) action_list (Or (filter, ip_filter)) xs
          else let next_loc_pkr = 
                  if String.equal interface "Loopback0"
                    then parse_location_to_pkr loc (header_placement Loc nodes) true nodes
                    (* Setting the discard the testing interface *)
                  else if String.equal interface "null_interface" 
                    then Binary (False,False)
                    (* Neglect the interface sending to nowhere/outside network *)
                  else try (parse_location_to_pkr (find_next_loc loc interface edges) (header_placement Loc nodes) false nodes)
                    with _ -> Binary (False,False) in
            aux re_routing_list (action_list @ [(ip,mask, And (Neg filter,ip_filter), next_loc_pkr)]) (Or (filter, ip_filter)) xs
    in
  let (re_routing_list, action_list) = aux [] [] False (List.sort compare_data tables) in
    let rec action_lookup (action_list:(int*int*pred*pkr) list) (ip:int) : pkr =
      match action_list with
      | [] -> Binary (False,False)
      | (ip2,mask,_,action)::xs ->
          if match_ip_string ip ip2 mask then
            action
          else action_lookup xs ip
    in
    List.fold_right (fun (ip,pred) acc -> OrP (AndP (Binary (pred,True), action_lookup action_list ip), acc)) re_routing_list
      (List.fold_right (fun (_,_,pred,action) acc -> OrP (AndP (Binary (pred,True), action), acc)) action_list (Binary (False,False)))

let rec parse_global_routing_table (table:Yojson.Basic.t) (nodes: int NodesMap.t) (edges: (string*string)EdgesMap.t) : pkr = 
  match table with
  | `Assoc ((loc, `List routing_table)::xs) ->
      let loc_filter = parse_location_to_pred loc (header_placement Loc nodes) false nodes in
        let action = parse_local_routing_table loc routing_table nodes edges in
         OrP (AndP (Binary (loc_filter,True), action), parse_global_routing_table (`Assoc xs) nodes edges)
  | `List []
  | `Assoc [] -> Binary (False,False)
  | _ -> failwith "Unexpected JSON format for routing table, please check the json generated by the batfish is in orient format of 'Record'"        

let json_to_network (table:Yojson.Basic.t) (nodes: int NodesMap.t) (edges: (string*string)EdgesMap.t) (dup_free:bool) (start_list:string list) (end_list:string list) : NK.t =
  let routing_table = parse_global_routing_table table nodes edges in
  let start_loc = List.fold_left (fun acc loc ->
    let start_loc = parse_location_to_pred loc (header_placement Loc nodes) false nodes in
    Or (acc, start_loc)
  ) False start_list in
  let end_loc = List.fold_left (fun acc loc ->
    let end_loc = parse_location_to_pred loc (header_placement Loc nodes) false nodes in
    Or (acc, end_loc)
  ) False end_list in
  let start_filter = AndP (Binary (start_loc,True), Id) in
  let end_filter = AndP (Binary (end_loc,True), Id) in
  let open RN.NK in
  let network = 
    if dup_free then
      Star (Pkr routing_table)
    else
      Star (Seq (Dup,Pkr routing_table)) in
  Seq (Pkr start_filter, Seq (network,Pkr end_filter))

let network_compiler (routings:Yojson.Basic.t) (edges: Yojson.Basic.t) (dup_free:bool) (start_list:string list) (end_list:string list) : NK.t =
  let edges = parse_edges_to_map edges in
  let nodes = parse_nodes_to_map routings in
  json_to_network routings nodes edges dup_free start_list end_list